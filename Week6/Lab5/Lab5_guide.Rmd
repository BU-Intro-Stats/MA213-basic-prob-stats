---
title: "MA213 Basic Statistics and Probability - Lab5 guide"
output:
  html_document:
    code_download: true 
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(dplyr)
```

# **Lab 5: Simulation and probability**

In this lab session, we will explore key concepts of inferential statistics which include sampling distribution and central limit theorem.

------------------------------------------------------------------------

#### Learning Objectives

-   Apply the Law of Large Numbers and Its Implications: Explain the Law of Large Numbers, why it holds, and its implications for predicting long-term averages in probability and statistics.

-   Model Data Using Bernoulli, Geometric, and Binomial Distributions: Recognize when to appropriately model data using the Bernoulli, geometric, and binomial distributions, and compute quantities of interest such as mean, standard deviation, and tail probabilities.

-   Assess Data Using the Normal Distribution: Use the normal distribution to assess the "unusualness" of data points, apply the 68-95-99.7% rule, evaluate normality through histograms and q-q plots, and determine when a normal approximation to the binomial model is valid for calculating binomial probabilities.

-   Understand Point Estimates and Sampling Variability: Define a sample statistic (point estimate) for a population parameter, and explain how it varies across different samples.

-   Visualize and Interpret Sampling Distributions: Draw and interpret sampling distributions for a point estimate (e.g., population proportion) across different sample sizes, explaining how the distribution changes as the sample size increases.

-   Calculate and Interpret Standard Error: Calculate the standard error for proportions and interpret it as a measure of sampling variability.

------------------------------------------------------------------------

-   The role of sampling distribution : Why do we care about sampling distribution?

    1.  What is sampling distribution?

    -\> In inferential statistics, we estimate the characteristics of the population parameter by using characteristics of sample (statistic).

    -\> The distribution of the statistic obtained from sample is called sampling distribution.

![](Sampling_diag.jpeg){width="100%"}

\

We have a hypothetical population that are

``` r
pop <- c(rep("Apple", 10), rep("Android", 4))
```

So that the true proportion of having apple device is $p=\frac{10}{14}$.

Let's sample them with $n=5$. What does the sampling distribution look like?

1.  Let's take a sample from the population `pop` and assign it to an object called `p_hat`.

    (Hint: Use the `sample()` function. Also, count how many apples are in the sample.)

```{r}
pop <- c(rep("Apple", 10), rep("Android", 4)) # population
true_proportion <- sum(pop == "Apple") / n
true_proportion  # population proportion p


n = 5 #sample size
my_sample <- sample(pop, n)
p_hat <- sum(my_sample == "Apple") / n
p_hat # sample proportion p_hat
```

2.  What is the sampling distribution looks like?

1). Obtain sample from population

2). Obtain sample statistics `p_hat` from the sample

3). Repeat steps 1 and 2 $K$ times

(hint : Use `for loop` )

```{r}
K = 100
p_hat_vector <-rep(0,K)

for (k in 1:K){
  my_sample <- sample(pop, n)
  p_hat <- sum(my_sample == "Apple") / n
  p_hat_vector[k] <- p_hat
}
p_hat_vector


```

3.  Using `p_hat_vector` , show the shape of sampling distribution.

```{r}
sample_data <- data.frame(p_hat = p_hat_vector) #p_hat is the name of the column

ggplot(data=sample_data, aes(x=p_hat)) + geom_histogram(bins=20)


```

4.  Let's increase the population size to 1,400. Now you are given a much larger population:

    ``` r
    pop <- c(rep("Apple", 1000), rep("Android", 400))
    ```

    You know the true population proportion of "Apple" is $p = 0.7142$. Let's create a function `my_sample_phat()` that takes a sample size `n` as input and returns a vector of sample proportions named `p_hat_vector` based on repeated sampling.

    ```{r}
    # population
    pop <- c(rep("Apple", 1000), rep("Android", 400))

    # Function to calculate sample proportions over K samples
    my_sample_phat <- function(n, K = 500){
      p_hat_vector <- numeric(K)         # Initialize vector to store sample proportions
      
      for (k in 1:K){
        my_sample <- sample(pop, n, replace = TRUE)   
        p_hat_vector[k] <- sum(my_sample == "Apple") / n    # Calculate proportion of "Apple"
      }
      return(p_hat_vector)
    }

    # Example usage
    head(my_sample_phat(10))
    head(my_sample_phat(100))

    ```

5.  Using `my_sample_phat``()` function, show the probability mass function (pmf) of the sampling distribution of $\hat{p}$. Set `n=1000` . What do you conclude?

```{r}
library(dplyr)
n=1000
p_hat_vector = my_sample_phat(n)

p_hat_data <- data.frame(p_hat = p_hat_vector)


p_hat_data <- p_hat_data %>%
  count(p_hat) %>%
  mutate(pmf = n/sum(n))


mean(p_hat_data$p_hat)
sd(p_hat_data$p_hat)

ggplot(p_hat_data, aes(x=p_hat, y=pmf)) + geom_point() + geom_smooth()



```

Easier version to show the shape of the distribution is to show histogram of sampled `p_hat_vector`.

```{r}
n=1000
p_hat_vector = my_sample_phat(n)
p_hat_data <- data.frame(p_hat = p_hat_vector)
ggplot(data=p_hat_data, aes(x = p_hat)) + geom_histogram(bin=30)



```

Can we also check whether $\hat{p}$ follows normal distribution in a different way?

We can check it through 68-95-99.7 rule.

```{r}

p_hat_vector = my_sample_phat(1000)

p_hat_data <- data.frame(p_hat = p_hat_vector)



# mean
p_hat_mean = mean(p_hat_data$p_hat)

# standard deviation
p_hat_sd = sd(p_hat_data$p_hat)
p_hat_sd



# let's check 68-95-99.7 rule

df <- p_hat_data$p_hat

# within 1 standard deviation
range = (df > (p_hat_mean - 1 * p_hat_sd)) & (df < (p_hat_mean + 1 * p_hat_sd))
df_temp <- df[ range ]
length(df_temp) / length(df)


# within 2 standard deviation
range = (df > (p_hat_mean - 2 * p_hat_sd)) & (df < (p_hat_mean + 2 * p_hat_sd))
df_temp <- df[ range ]
length(df_temp) / length(df)


# within 3 standard deviation
range = (df > (p_hat_mean - 3 * p_hat_sd)) & (df < (p_hat_mean + 3 * p_hat_sd))
df_temp <- df[ range ]
length(df_temp) / length(df)

```
